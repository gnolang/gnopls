package main

import (
	"fmt"

	"github.com/dave/jennifer/jen"
	"go.lsp.dev/protocol"
)

const (
	protoPkg           = "go.lsp.dev/protocol"
	completionItemType = "CompletionItem"
)

// buildSourceFile constructs a Go source file with map that contains completion items.
func buildSourceFile(pkgName string, src []protocol.CompletionItem) (*jen.File, error) {
	f := jen.NewFile(pkgName)
	f.HeaderComment("This file was generated by genbuiltin, DO NOT EDIT!")
	f.HeaderComment("See: /tools/genbuiltin")

	f.ImportName(protoPkg, "")

	bucketStmt, err := buildBucketMapStatement(src)
	if err != nil {
		return nil, err
	}

	f.Comment("Buckets contains list of completions for builtin Gno functions grouped by a first letter.")
	f.Var().Id("Buckets").Op("=").Map(jen.Rune()).Index().Qual(protoPkg, completionItemType).Values(bucketStmt)
	return f, nil
}

func buildBucketMapStatement(src []protocol.CompletionItem) (jen.Dict, error) {
	grouped := make(map[rune][]jen.Code)
	for _, item := range src {
		key := []rune(item.Label)[0]
		stmt, err := completionItemToStatement(item)
		if err != nil {
			return nil, err
		}

		grouped[key] = append(grouped[key], stmt)
	}

	dict := jen.Dict{}
	for key, entries := range grouped {
		lit := jen.Lit(key)
		dict[lit] = jen.Index().Qual(protoPkg, completionItemType).Values(entries...)
	}

	return dict, nil
}

func completionItemToStatement(item protocol.CompletionItem) (jen.Code, error) {
	var docStmt *jen.Statement
	switch doc := item.Documentation.(type) {
	case protocol.MarkupContent:
		docStmt = jen.Qual(protoPkg, "MarkupContent").Values(jen.Dict{
			jen.Id("Kind"):  jen.Qual(protoPkg, "Markdown"),
			jen.Id("Value"): jen.Lit(doc.Value),
		})
	case string:
		docStmt = jen.Lit(doc)
	default:
		return nil, fmt.Errorf("unexpected documentation field type: %#v", doc)
	}

	var insertTextFormatStmt *jen.Statement
	switch v := item.InsertTextFormat; v {
	case protocol.InsertTextFormatPlainText,
		protocol.InsertTextFormatSnippet:
		constId := "InsertTextFormat" + v.String()
		insertTextFormatStmt = jen.Qual(protoPkg, constId)
	default:
		insertTextFormatStmt = jen.Lit(float64(v))
	}

	var itemKindStmt *jen.Statement
	switch item.Kind {
	case
		protocol.CompletionItemKindText,
		protocol.CompletionItemKindMethod,
		protocol.CompletionItemKindFunction,
		protocol.CompletionItemKindConstructor,
		protocol.CompletionItemKindField,
		protocol.CompletionItemKindVariable,
		protocol.CompletionItemKindClass,
		protocol.CompletionItemKindInterface,
		protocol.CompletionItemKindModule,
		protocol.CompletionItemKindProperty,
		protocol.CompletionItemKindUnit,
		protocol.CompletionItemKindValue,
		protocol.CompletionItemKindEnum,
		protocol.CompletionItemKindKeyword,
		protocol.CompletionItemKindSnippet,
		protocol.CompletionItemKindColor,
		protocol.CompletionItemKindFile,
		protocol.CompletionItemKindReference,
		protocol.CompletionItemKindFolder,
		protocol.CompletionItemKindEnumMember,
		protocol.CompletionItemKindConstant,
		protocol.CompletionItemKindStruct,
		protocol.CompletionItemKindEvent,
		protocol.CompletionItemKindOperator,
		protocol.CompletionItemKindTypeParameter:
		constId := "CompletionItemKind" + item.Kind.String()
		itemKindStmt = jen.Qual(protoPkg, constId)
	default:
		// Unknown value, write as is.
		itemKindStmt = jen.Lit(int(item.Kind))
	}

	dict := jen.Dict{
		jen.Id("Label"):            jen.Lit(item.Label),
		jen.Id("Kind"):             itemKindStmt,
		jen.Id("Detail"):           jen.Lit(item.Detail),
		jen.Id("InsertTextFormat"): insertTextFormatStmt,
		jen.Id("InsertText"):       jen.Lit(item.InsertText),
		jen.Id("Documentation"):    docStmt,
	}

	return jen.Qual(protoPkg, completionItemType).Values(dict), nil
}
